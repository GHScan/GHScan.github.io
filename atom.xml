<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scan的博客</title>
  <subtitle>上士闻道，勤而行之</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.wbscan.com/"/>
  <updated>2016-05-08T15:23:17.725Z</updated>
  <id>http://blog.wbscan.com/</id>
  
  <author>
    <name>Scan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>怎样在.Net中查找特定对象的所有根路径</title>
    <link href="http://blog.wbscan.com/2016/05/08/HowToFigureOutTheRootPathsOfDotNetObject/"/>
    <id>http://blog.wbscan.com/2016/05/08/HowToFigureOutTheRootPathsOfDotNetObject/</id>
    <published>2016-05-08T13:34:24.000Z</published>
    <updated>2016-05-08T15:23:17.725Z</updated>
    
    <content type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://blog.wbscan.com/2016/05/08/HowToCatpureAndUseMiniDump/&quot;&gt;上文&lt;/a&gt; 提到，Vistual Studio能够在加载了MiniDump文件后，查找特定对象在GC系统中的所有根路径 (关于GC和Root Set的概念，参见&lt;a href=&quot;https://en.wikipedia.org/wiki/Tracing_garbage_collection&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Tracing GC&lt;/a&gt;)。这是非常强大的功能，而第一次注意到调试工具具备这个能力，是上次我在使用&lt;a href=&quot;https://www.jetbrains.com/help/dotmemory/10.0/Analyzing_GC_Roots.html?origin=old_help&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;dotMemory&lt;/a&gt;的时候。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;幸运的是，没过多久，我在自己用到的开源库中，也发现了演示这个功能的&lt;a href=&quot;https://github.com/Microsoft/dotnetsamples/tree/master/Microsoft.Diagnostics.Runtime/CLRMD/GCRoot&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Demo&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;clrmd介绍&quot;&gt;&lt;a href=&quot;#clrmd介绍&quot; class=&quot;headerlink&quot; title=&quot;clrmd介绍&quot;&gt;&lt;/a&gt;clrmd介绍&lt;/h3&gt;&lt;p&gt;先介绍下用到的库&lt;a href=&quot;https://github.com/microsoft/clrmd&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;clrmd&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;CLR MD is a C# API used to build diagnostics tools. It gives you the power and flexibility of what the SOS and PSSCOR debugger extensions can do in a simple, fast C# API.&lt;/p&gt;
&lt;p&gt;Some features include:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Memory Diagnostics&lt;/li&gt;
&lt;li&gt;Walking the GC Heap.&lt;/li&gt;
&lt;li&gt;Walking roots in the process.&lt;/li&gt;
&lt;li&gt;Walking all heaps that CLR owns, such as JIT code heaps, AppDomain heaps, etc.&lt;/li&gt;
&lt;li&gt;Walk threads in the process to get managed callstacks.&lt;/li&gt;
&lt;li&gt;Walk AppDomains in the process.&lt;/li&gt;
&lt;li&gt;Walk COM wrappers in your process (v4.5+ only).&lt;/li&gt;
&lt;li&gt;And more…&lt;/li&gt;
&lt;/ul&gt;
&lt;footer&gt;&lt;strong&gt;Microsoft&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://github.com/microsoft/clrmd&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Microsoft.Diagnostics.Runtime&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;p&gt;之前同事用这个库attach到我们生产服的进程中，提取一些实时的CLR状态，后来我接手做一些收尾工作的时候，发现了它本身提供的&lt;a href=&quot;https://github.com/Microsoft/dotnetsamples/tree/master/Microsoft.Diagnostics.Runtime/CLRMD&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Examples&lt;/a&gt;。出于谨慎起见，我把每个Example给读了下，想看看产品代码里有没什么遗漏，结果发现了这个&lt;a href=&quot;https://github.com/Microsoft/dotnetsamples/tree/master/Microsoft.Diagnostics.Runtime/CLRMD/GCRoot&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Demo&lt;/a&gt;，它在做基于clrmd的根路径查找。&lt;/p&gt;
&lt;h3 id=&quot;源码分析&quot;&gt;&lt;a href=&quot;#源码分析&quot; class=&quot;headerlink&quot; title=&quot;源码分析&quot;&gt;&lt;/a&gt;源码分析&lt;/h3&gt;&lt;p&gt;我们直接开始分析它的代码。&lt;/p&gt;
&lt;p&gt;首先它加载MiniDump：&lt;br&gt;&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;DataTarget dataTarget = DataTarget.LoadCrashDump(dump);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;顺带一说，这个库也是可以attach到live进程的: &lt;/p&gt;
&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; DataTarget &lt;span class=&quot;title&quot;&gt;AttachToProcess&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; pid, &lt;span class=&quot;keyword&quot;&gt;uint&lt;/span&gt; msecTimeout`&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/blockquote&gt;
&lt;p&gt;然后枚举根集：&lt;br&gt;&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;doctag&quot;&gt;///&lt;/span&gt; Enumerate the roots of the process.  (That is, all objects which keep other objects alive.)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; IEnumerable&amp;lt;ClrRoot&amp;gt; &lt;span class=&quot;title&quot;&gt;EnumerateRoots&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;我们看下所谓根对象(ClrRoot)是什么：(原谅我擅自去掉了一些无关信息)&lt;br&gt;&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;doctag&quot;&gt;///&lt;/span&gt; Represents a root in the target process.  A root is the base entry to the GC&#39;s mark and sweep algorithm.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ClrRoot&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;doctag&quot;&gt;///&lt;/span&gt; A GC Root also has a Kind, which says if it is a strong or weak root&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; GCRootKind Kind &amp;#123; &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;doctag&quot;&gt;///&lt;/span&gt; The name of the root.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;string&lt;/span&gt; Name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;doctag&quot;&gt;///&lt;/span&gt; The type of the object this root points to.  That is, ClrHeap.GetObjectType(ClrRoot.Object).&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; ClrType Type &amp;#123; &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;doctag&quot;&gt;///&lt;/span&gt; The object on the GC heap that this root keeps alive.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;ulong&lt;/span&gt; Object &amp;#123; &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;doctag&quot;&gt;///&lt;/span&gt; The address of the root in the target process.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;ulong&lt;/span&gt; Address &amp;#123; &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt;; &lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt;; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;doctag&quot;&gt;///&lt;/span&gt; Returns true if the root &quot;pins&quot; the object, preventing the GC from relocating it.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; IsPinned;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;这里我们比较感兴趣的是GCRootKind:&lt;br&gt;&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&lt;span class=&quot;doctag&quot;&gt;///&lt;/span&gt; The type of GCRoot that a ClrRoot represnts.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;enum&lt;/span&gt; GCRootKind&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  StaticVar = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  ThreadStaticVar = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  LocalVar = &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Strong = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Weak = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Pinning = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Finalizer = &lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  AsyncPinning = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Max = &lt;span class=&quot;number&quot;&gt;7&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;所以说，这里所谓ClrRoot对象，是指一个静态变量/线程局部变量/局部变量等，而它的值，是一个引用对象。&lt;/p&gt;
&lt;p&gt;枚举的根基，被放到一个字典里面：&lt;br&gt;&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Dictionary&amp;lt;&lt;span class=&quot;keyword&quot;&gt;ulong&lt;/span&gt;, List&amp;lt;ClrRoot&amp;gt;&amp;gt; m_rootDict = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span class=&quot;keyword&quot;&gt;ulong&lt;/span&gt;, List&amp;lt;ClrRoot&amp;gt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;其中，key是ClrRoot的值，value是指向相同引用对象的所有根(或者说局部变量和静态变量)。&lt;/p&gt;
&lt;p&gt;查找算法在FindPathToTarget里面：&lt;br&gt;&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Node &lt;span class=&quot;title&quot;&gt;FindPathToTarget&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;ClrHeap heap, ClrRoot root&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;它尝试判断是否存在从指定根root到目标对象的一条路径，如果有，则返回路径链表的头结点。&lt;/p&gt;
&lt;p&gt;在函数体中，需要遍历对象任意对象的子引用，这就是个trace的过程:&lt;br&gt;&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curr.Type.EnumerateRefsOfObject(curr.Object, &lt;span class=&quot;keyword&quot;&gt;delegate&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;ulong&lt;/span&gt; child, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; offset)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;到这里，你已经可以想到FindPathToTarget的内部是怎么实现了，无非是对对象图的深度优先的搜索。由于这个图没有任何规律，所以搜索算法必须是迭代而不能是递归(否则爆栈)。&lt;/p&gt;
&lt;p&gt;图搜索的过程中，一个对象（图节点）一旦被访问，就应该被标记，由于标记本身不能存储在对象内部（clrmd只暴露了只读接口），所以需要一个高效的标记集合表示（对象数可能非常大，考虑你可能是在几十GB的堆中进行搜索）。&lt;/p&gt;
&lt;p&gt;为了存储对象标记，这个工具实现了这么个类：&lt;br&gt;&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ObjectSet&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ObjectSet&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;ClrHeap heap&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Add&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ulong&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Contains&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ulong&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; Count;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;如你所见，从接口上来说，其实就是个HashSet&amp;lt;ulong&amp;gt;，只是内部利用了object地址的特殊性，进行了优化。&lt;/p&gt;
&lt;p&gt;具体来说，ClrHeap对象有个字段叫Segments，里面是一个ClrSegment的序列，其中ClrSegment的Start/End字段表示了这个Heap segment的地址范围。从ObjectSet的实现来看，每个对象的object size， 是对齐到指针大小的（IntPtr.Size），所以一个ClrSegment可以看做一系列Word，如果只是为了用作集合、做存在性测试的话，那么，一个Word可以表示为一个bit，于是ClrSegment就对应于一个BitArray，而一个object就是BitArray中一个连续的bit序列。由于对象本身一定不会重叠，因此，我们关心的实际只是对象头所在的bit，因此，判断一个对象是否存在，其实就是判断对象头所对应的bit有没在BitArray中被标记。&lt;br&gt;基于这个讨论，可以看到Contains是这么实现的：&lt;br&gt;&lt;figure class=&quot;highlight csharp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Contains&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;ulong&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt; == &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; m_zero;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; segmentIndex = GetSegmentIndex(&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (segmentIndex == &lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; headBitIndex = (&lt;span class=&quot;keyword&quot;&gt;value&lt;/span&gt; - m_segments[segmentIndex].Low) / IntPtr.Size;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; m_bitArrays[segmentIndex][headBitIndex];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到，ObjectSet通过识别ClrSegment集合，来针对地址空间的非连续性做优化；又通过object size是字长对齐的这一特点，以一个bit代表一个字。ObjectSet在这里做的优化，确保了，即使被查找的进程堆很大，搜索进程的内存占用至少在1/64以下（x64的时候）。&lt;/p&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;其实所谓根路径查找的算法很容易理解，难得的是这里一个几百行的小Demo，就演示了怎样对一个产品级的虚拟机进行搜索，挺有意思。&lt;/p&gt;
&lt;h3 id=&quot;其他Example&quot;&gt;&lt;a href=&quot;#其他Example&quot; class=&quot;headerlink&quot; title=&quot;其他Example&quot;&gt;&lt;/a&gt;其他Example&lt;/h3&gt;&lt;p&gt;clrmd的&lt;a href=&quot;https://github.com/Microsoft/dotnetsamples/tree/master/Microsoft.Diagnostics.Runtime/CLRMD&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Examples&lt;/a&gt;里面还有其他几个例子，我也稍微提一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DumpHeapLive: 打印所有可达的GC对象。结合上面的ObjectSet，它进行了可达性追踪。&lt;/li&gt;
&lt;li&gt;DumpDiff: 把两个MiniDump中的对象，以对象类型聚合过后，比较两个聚合结果在相同类型上的对象数、总尺寸的变化。&lt;/li&gt;
&lt;li&gt;DumpDict: 打印给定地址的中的&lt;code&gt;System.Collections.Generic.Dictionary&lt;/code&gt;键值对&lt;/li&gt;
&lt;li&gt;ClrStack: 打印所有线程的调用栈，以及栈上局部变量。&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://blog.wbscan.com/2016/05/08/HowToCatpureAndUseMiniDump/&quot;&gt;上文&lt;/a&gt; 提到，Vistual Studio能够在加载了MiniDump文件后，查找特定对象在GC系统中的所有根路径 (关于GC和Root Set的概念，参见&lt;a href=&quot;https://en.wikipedia.org/wiki/Tracing_garbage_collection&quot;&gt;Tracing GC&lt;/a&gt;)。这是非常强大的功能，而第一次注意到调试工具具备这个能力，是上次我在使用&lt;a href=&quot;https://www.jetbrains.com/help/dotmemory/10.0/Analyzing_GC_Roots.html?origin=old_help&quot;&gt;dotMemory&lt;/a&gt;的时候。&lt;br&gt;
    
    </summary>
    
      <category term="VirtualMachine" scheme="http://blog.wbscan.com/categories/VirtualMachine/"/>
    
    
      <category term=".Net" scheme="http://blog.wbscan.com/tags/Net/"/>
    
      <category term="GC" scheme="http://blog.wbscan.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>MiniDump文件的多种创建和使用方法</title>
    <link href="http://blog.wbscan.com/2016/05/08/HowToCatpureAndUseMiniDump/"/>
    <id>http://blog.wbscan.com/2016/05/08/HowToCatpureAndUseMiniDump/</id>
    <published>2016-05-08T12:16:10.000Z</published>
    <updated>2016-05-08T13:17:45.703Z</updated>
    
    <content type="html">&lt;p&gt;前面两篇文章(&lt;a href=&quot;http://blog.wbscan.com/2016/05/08/StructuredExceptionHandling/&quot;&gt;1&lt;/a&gt;, &lt;a href=&quot;http://blog.wbscan.com/2016/05/08/CreateMiniDumpWithWindowsApi/&quot;&gt;2&lt;/a&gt;)从编程角度讲了Windows异常处理机制和用API创建MinDump文件，这里再来讲一些其他创建MiniDump的方式，以及MiniDump文件的基本使用。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;创建MiniDump文件&quot;&gt;&lt;a href=&quot;#创建MiniDump文件&quot; class=&quot;headerlink&quot; title=&quot;创建MiniDump文件&quot;&gt;&lt;/a&gt;创建MiniDump文件&lt;/h3&gt;&lt;p&gt;由于不同事故现场有自己的限制，可能用户程序根本没有主动生成MiniDump文件，或者程序在运行、但你想要去诊断它的状态。&lt;/p&gt;
&lt;p&gt;这篇&lt;a href=&quot;http://www.wintellect.com/devcenter/jrobbins/how-to-capture-a-minidump-let-me-count-the-ways&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文章&lt;/a&gt;列举了各种MiniDump生成方法，我认为很有价值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.windbg.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;WinDBG&lt;/a&gt;的&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/hardware/ff562428%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;.dump&lt;/a&gt;命令&lt;/li&gt;
&lt;li&gt;Visual Studio的&lt;code&gt;将转储另存为&lt;/code&gt;菜单项：调试状态下，&lt;code&gt;调试 -&amp;gt; 将转储另存为&lt;/code&gt;。可以选择创建Mini Dump或者Full Dump。&lt;/li&gt;
&lt;li&gt;任务管理器：&lt;code&gt;选中进程 -&amp;gt; 创建转储文件&lt;/code&gt;，这里创建的是Full Dump。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://technet.microsoft.com/en-us/sysinternals/bb896653.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Process Explorer&lt;/a&gt;: &lt;code&gt;选中进程 -&amp;gt; 创建Mini Dump/Full Dump&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://technet.microsoft.com/en-us/sysinternals/dd996900.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ProcDump&lt;/a&gt;: ProcDump可以基于各种条件来创建Mini Dump或者Full Dump，比如：&lt;ul&gt;
&lt;li&gt;procdump notepad: 为notepad创建Mini Dump&lt;/li&gt;
&lt;li&gt;procdump -ma 4572: 为pid为4572的进程创建Full Dump&lt;/li&gt;
&lt;li&gt;procdump -mp -e store.exe: 当store.exe遇到第一个未处理异常的时候，为它创建一个比Mini Dump信息稍多的Dump文件&lt;/li&gt;
&lt;li&gt;procdump -c 20 -s 5 -n 3 consume: 监视consume进程，一旦它连续5秒的CPU使用率都超过20%，则创建MiniDump，总共最多Dump 3次。之后，你可以用这不同的Dump来做对比等。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过Windows API &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms680360.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MiniDumpWriteDump&lt;/a&gt; 创建转储文件，能够在代码中精确的控制需要转储的进程信息。这是我们上篇文章做的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;使用MiniDump文件&quot;&gt;&lt;a href=&quot;#使用MiniDump文件&quot; class=&quot;headerlink&quot; title=&quot;使用MiniDump文件&quot;&gt;&lt;/a&gt;使用MiniDump文件&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;使用Visual Studio，&lt;code&gt;文件 -&amp;gt; 打开 -&amp;gt; 文件&lt;/code&gt;选中刚才创建的MiniDump文件即可。这个MiniDump文件，如果是从Managed进程生成的，那么用法会更丰富。&lt;ul&gt;
&lt;li&gt;Native程序生成的MiniDump: 一般能够查看调用栈，如果是Full Dump的话，往往还可以查看堆数据。注意，如果MiniDump不是基于异常生成的，而是直接创建的，那么可以通过&lt;code&gt;调试 -&amp;gt; 窗口 -&amp;gt; 线程&lt;/code&gt;来查看所有线程的调用栈。&lt;/li&gt;
&lt;li&gt;Manged程序生成的MiniDump: 线程状态的诊断和Native程序差不多，但打开Managed程序的Dump文件时，多了一个菜单项是&lt;code&gt;调试托管内存&lt;/code&gt;，这个功能很强大：&lt;ul&gt;
&lt;li&gt;查找托管堆中指定类型的所有对象 &lt;/li&gt;
&lt;li&gt;查找特定对象所包含的引用&lt;/li&gt;
&lt;li&gt;查找从GC根集到特定对象的所有引用路径。这是非常强大的特性，在资源泄露的排查中非常有帮助。比如，你发现程序的内存一直上涨，并且特定类型对象特别多，那么，利用Visual Studio的这个功能，选中异常类型的一个实例，就能看到它为什么还被引用住，而没有释放了（比如，被添加到一个static的字典里面，由于逻辑错误，没有被正常移除）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用WinDBG或者&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/hardware/hh406277%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;cdb&lt;/a&gt;。这些工具尺寸小，往往可以直接用于在生产服上的本机调试，但缺乏对Managed程序的特殊调试支持。另外，相比Visual Studio，上手曲线更大。作为初步诊断，可以直接在目标机上，通过任务管理器创建MiniDump，然后运行&lt;code&gt;cdb -c &amp;quot;~*kv; q&amp;quot; -y SymbolPath -z DumpFile&lt;/code&gt;命令，这将打印所有线程的Stack trace，能用于处理一些简单问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;这里讲了各种MiniDump文件的创建方式和基本使用，对常见问题诊断很有帮助。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;前面两篇文章(&lt;a href=&quot;http://blog.wbscan.com/2016/05/08/StructuredExceptionHandling/&quot;&gt;1&lt;/a&gt;, &lt;a href=&quot;http://blog.wbscan.com/2016/05/08/CreateMiniDumpWithWindowsApi/&quot;&gt;2&lt;/a&gt;)从编程角度讲了Windows异常处理机制和用API创建MinDump文件，这里再来讲一些其他创建MiniDump的方式，以及MiniDump文件的基本使用。&lt;br&gt;
    
    </summary>
    
      <category term="Error Handling" scheme="http://blog.wbscan.com/categories/Error-Handling/"/>
    
    
      <category term="Windows" scheme="http://blog.wbscan.com/tags/Windows/"/>
    
      <category term="Exception" scheme="http://blog.wbscan.com/tags/Exception/"/>
    
      <category term="MiniDump" scheme="http://blog.wbscan.com/tags/MiniDump/"/>
    
      <category term="SEH" scheme="http://blog.wbscan.com/tags/SEH/"/>
    
  </entry>
  
  <entry>
    <title>用MiniDumpWriteDump来创建MiniDump</title>
    <link href="http://blog.wbscan.com/2016/05/08/CreateMiniDumpWithWindowsApi/"/>
    <id>http://blog.wbscan.com/2016/05/08/CreateMiniDumpWithWindowsApi/</id>
    <published>2016-05-08T10:59:44.000Z</published>
    <updated>2016-05-08T12:07:43.827Z</updated>
    
    <content type="html">&lt;p&gt;上一篇&lt;a href=&quot;http://blog.wbscan.com/2016/05/08/StructuredExceptionHandling/&quot;&gt;文章&lt;/a&gt;讨论了SEH，这里就基于它做点事儿。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;任务很简单，就是在发现一个未处理异常时，使用&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms680360%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MiniDumpWriteDump&lt;/a&gt;创建一个Full Dump文件，从而允许之后的异常调试：&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;dbghelp.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;pragma&lt;/span&gt; comment (lib, &lt;span class=&quot;string&quot;&gt;&quot;dbghelp.lib&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;LONG WINAPI &lt;span class=&quot;title&quot;&gt;MyUnhandledExceptionFilter&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(EXCEPTION_POINTERS *exceptionPointers)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    HANDLE file = CreateFile(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;string&quot;&gt;L&quot;FullDump.dmp&quot;&lt;/span&gt;, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        GENERIC_READ | GENERIC_WRITE,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nullptr, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        CREATE_ALWAYS, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        FILE_ATTRIBUTE_NORMAL, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        nullptr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MINIDUMP_EXCEPTION_INFORMATION miniDumpExceptionInfo = &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        GetCurrentThreadId(), &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        exceptionPointers, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        FALSE&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MINIDUMP_TYPE mdt = &lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;MINIDUMP_TYPE&amp;gt;(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MiniDumpWithFullMemory |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MiniDumpWithFullMemoryInfo |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MiniDumpWithHandleData |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MiniDumpWithThreadInfo |&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        MiniDumpWithUnloadedModules);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    MiniDumpWriteDump(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        GetCurrentProcess(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        GetCurrentProcessId(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        file, mdt,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        (exceptionPointers != nullptr) ? &amp;amp;miniDumpExceptionInfo : &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;literal&quot;&gt;nullptr&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;literal&quot;&gt;nullptr&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    CloseHandle(file);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return EXCEPTION_EXECUTE_HANDLER;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SetUnhandledExceptionFilter(MyUnhandledExceptionFilter);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *&lt;span class=&quot;keyword&quot;&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;*&amp;gt;(&lt;span class=&quot;literal&quot;&gt;nullptr&lt;/span&gt;) = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从事故现场拿到这个”FullDump.dmp”文件后，挂到Visual Studio或者WinDbg中，就可以调试现场了，包括调用栈和全局变量、堆数据都可以访问。&lt;/p&gt;
&lt;p&gt;上面的代码是在发现未处理异常的时候写MiniDump文件的，此时的选择只剩下结束进程。其实也可以选择在任何一个__except的filter表达式中创建MiniDump，然后在其对应的handler中访问这个文件，并且选择不退出、继续执行。&lt;/p&gt;
&lt;p&gt;如果我们创建的MiniDump，是用来诊断异常现场的，那么，MiniDump所需要的MINIDUMP_EXCEPTION_INFORMATION，只能由SEH filter提供，即在__except的filter expression中调用GetExceptionInformation或者通过SetUnhandledExceptionFilter注册成filter之后接受传入的Callback参数。&lt;/p&gt;
&lt;p&gt;如果你不需要异常现场，只是想诊断为什么进程的内存占用很大，或者检查线程的非正常状态，那么，也可以将这个异常信息指针置为空，来简单的创建进程状态的Snapshot：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;ExceptionParam [in]&lt;br&gt;A pointer to a MINIDUMP_EXCEPTION_INFORMATION structure describing the client exception that caused the minidump to be generated. If the value of this parameter is NULL, no exception information is included in the minidump file.&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;MSDN&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms680360(v=vs.85).aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MiniDumpWriteDump Function&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;p&gt;上面的代码创建的是一个Full Dump，如果目标进程本身的&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/cc441804%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Working Set&lt;/a&gt;很大，那么Dump的时间和输出文件都会很大，影响服务器响应或者不容易分发。因此，你可以针对不同的目的，裁剪一些进程信息，创建更小的Dump文件。比如，一个只包括调用栈的Mini Dump可能已经足够你解决问题了。&lt;/p&gt;
&lt;p&gt;这里(&lt;a href=&quot;http://www.debuginfo.com/articles/effminidumps.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;1&lt;/a&gt;, &lt;a href=&quot;http://www.debuginfo.com/articles/effminidumps2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;2&lt;/a&gt;)是一些不错的讲这个主题的文章，然后&lt;a href=&quot;http://www.debuginfo.com/examples/effmdmpexamples.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;也给出了创建能用于不同场合的各种大小的Dump文件的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.debuginfo.com/examples/src/effminidumps/TinyDump.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;TinyDump&lt;/a&gt;: shows how to create the smallest possible minidump (more information&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.debuginfo.com/examples/src/effminidumps/MiniDump.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MiniDump&lt;/a&gt;: shows how to create a small but useful minidump (more information&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.debuginfo.com/examples/src/effminidumps/MidiDump.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MidiDump&lt;/a&gt;: shows how to create a relatively large but very informative minidump&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.debuginfo.com/examples/src/effminidumps/MaxiDump.cpp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MaxiDump&lt;/a&gt;: shows how to create a minidump that contains all possible kinds of information&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后，MiniDumpWriteDump 函数其实也可以用来为其他进程创建Mini Dump，只不过要求一些内存、线程访问权限：&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;hProcess [in]&lt;br&gt;A handle to the process for which the information is to be generated.&lt;br&gt;This handle must have PROCESS_QUERY_INFORMATION and PROCESS_VM_READ access to the process. If handle information is to be collected then PROCESS_DUP_HANDLE access is also required. For more information, see Process Security and Access Rights. The caller must also be able to get THREAD_ALL_ACCESS access to the threads in the process. For more information, see Thread Security and Access Rights.&lt;/p&gt;
&lt;footer&gt;&lt;strong&gt;MSDN&lt;/strong&gt;&lt;cite&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms680360(v=vs.85).aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;MiniDumpWriteDump Function&lt;/a&gt;&lt;/cite&gt;&lt;/footer&gt;&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;这个话题就讨论到这里，我们可以在我们的C++/.Net程序crash之前，搜集到足够的诊断信息，方便我们的调试了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇&lt;a href=&quot;http://blog.wbscan.com/2016/05/08/StructuredExceptionHandling/&quot;&gt;文章&lt;/a&gt;讨论了SEH，这里就基于它做点事儿。&lt;br&gt;
    
    </summary>
    
      <category term="Error Handling" scheme="http://blog.wbscan.com/categories/Error-Handling/"/>
    
    
      <category term="Windows" scheme="http://blog.wbscan.com/tags/Windows/"/>
    
      <category term="Exception" scheme="http://blog.wbscan.com/tags/Exception/"/>
    
      <category term="MiniDump" scheme="http://blog.wbscan.com/tags/MiniDump/"/>
    
      <category term="SEH" scheme="http://blog.wbscan.com/tags/SEH/"/>
    
  </entry>
  
  <entry>
    <title>Windows中的结构化异常处理</title>
    <link href="http://blog.wbscan.com/2016/05/08/StructuredExceptionHandling/"/>
    <id>http://blog.wbscan.com/2016/05/08/StructuredExceptionHandling/</id>
    <published>2016-05-07T21:33:42.000Z</published>
    <updated>2016-05-08T12:02:44.978Z</updated>
    
    <content type="html">&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;上一次在 Windows 上用 C/C++ 做正经项目、需要做严格异常处理和调试的场合，已经是 5 年前了，那时我还在维护 PC 端游戏引擎。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;在那以后，经历了移动开发到现在的 C# 开发，都不需要再跟 Windows 的结构化异常处理 (&lt;a href=&quot;https://zh.wikipedia.org/zh/%E7%BB%93%E6%9E%84%E5%8C%96%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SEH&lt;/a&gt;) 打交道。&lt;br&gt;虽说用不上，但看技术文档总有可能碰上，正好最近就有这样的场合，显然我已经把 &lt;a href=&quot;https://book.douban.com/subject/3235659/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《Windows核心编程》&lt;/a&gt; 里的细节给忘光光了，只能重新学习下。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;SEH的概念&quot;&gt;&lt;a href=&quot;#SEH的概念&quot; class=&quot;headerlink&quot; title=&quot;SEH的概念&quot;&gt;&lt;/a&gt;SEH的概念&lt;/h3&gt;&lt;p&gt;把 MSDN 上的&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms680657%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;文档&lt;/a&gt; 读了过后，发现最有价值的，还是&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms679270%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;首先，Windows 的 SEH 整个脉络是这样的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exception Triggering&lt;ul&gt;
&lt;li&gt;Guarded Body&lt;/li&gt;
&lt;li&gt;Raising Exception&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Exception Handling&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms679353%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Frame-based Exception Handling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms679270%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Vectored Exception Handling&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms681394%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Termination Handling&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分为异常触发和异常处理，而在编程层面讲，上面的功能需要藉由以下关键字或者函数来实施：(和上面一一对应)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Exception Triggering&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms679270%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;__try&lt;/a&gt; block&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms680552%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RaiseException&lt;/a&gt; function, 以及硬件异常(CPU 触发)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Exception Handling&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms679270%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;__except&lt;/a&gt; block, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms679356%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GetExceptionCode&lt;/a&gt;,  &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms679357%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GetExceptionInformation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms679273%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AddVectoredContinueHandler&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms680567%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RemoveVectoredContinueHandler&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms679274%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AddVectoredExceptionHandler&lt;/a&gt;, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms680571%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RemoveVectoredExceptionHandler&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms679270%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;__finally&lt;/a&gt; block, &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms679265%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;AbnormalTermination&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;SEH原理&quot;&gt;&lt;a href=&quot;#SEH原理&quot; class=&quot;headerlink&quot; title=&quot;SEH原理&quot;&gt;&lt;/a&gt;SEH原理&lt;/h3&gt;&lt;p&gt;假设给定一个 Call stack，每一个 Callsite ，都位于 Caller 的 __try block  中。那么，当最内层的一个函数调用 RaiseException 来抛出一个软件异常、或者在除零/非法内存访问抛出硬件异常的情形下，会发生这些事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当执行流进入一个函数的 __try block 时，会把 __except 的filtering expression (也就是 __except 的条件，在支持异常处理的高级语言中，对应 catch(e) 中的e )、handling block、以及 __finally block 这三个程序块儿的地址 push 到一个 thread local 的链表头上，从而将所有栈上 frame 的 exception handling 逻辑块串成一个链表&lt;/li&gt;
&lt;li&gt;当 Call stack 的栈顶上触发一次异常时，无论是软件异常还是硬件异常，OS 先准备异常码(GetExceptionCode 的返回值)和调用上下文 (包括当前线程的各种寄存器，即 GetExceptionInformation 的返回值)，然后以他们为参数 (除非用户在filter中完全没有访问这些信息)，逐个调用 thread local 的异常处理链中的 filter，检测每个 filter 的返回值，决定下一步行为。此时，filter 可以返回三种结果，来影响异常处理流程：&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/s58ftw19.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;EXCEPTION_CONTINUE_EXECUTION&lt;/a&gt;: 线程继续从异常触发点往下执行，即忽略异常。一般在返回该值之前 filter 需要调整 Eip/Rip 值，否则同样的异常会再次触发。如果一个 __except 的 filter 返回该值表示要继续执行，那么，通过 AddVectoredContinueHandler 注册的 handler 会被调用。&lt;/li&gt;
&lt;li&gt;EXCEPTION_CONTINUE_SEARCH: 沿异常处理链继续尝试下个 filter，即尝试调用栈上更外层函数的 __except 是否匹配。如果所有的用户定义的 __except 的 filter 块都匹配失败，则调用用户通过 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/windows/desktop/ms680634%28v=vs.85%29.aspx&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;SetUnhandledExceptionFilter&lt;/a&gt; 注册的顶层filter，一般用户可以在这个 filter 里面写 minidump 文件了。&lt;/li&gt;
&lt;li&gt;EXCEPTION_EXECUTE_HANDLER: 执行该 filter 对应的 handling block，即认为该 filter 匹配上了。由于匹配的 filter 所对应的 handler 很可能不在 Call stack 的栈顶，那么需要进行 Stack unwinding。在Stack unwinding 之前，如果用户通过 AddVectoredExceptionHandler 注册了 handler ，此时也会被调用；之所以要强调在栈开解之前调用 handler，是因为 handler 需要访问异常触发现场完整的栈。另外，在栈开解的同时，还要执行被弹出的 Stack frame 的相应 __finally 块的 handler。最后，执行完对应 __except 的 handler 块儿过后，线程继续从 __except 之后往下执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;恩，上面的过程很复杂，我们再简单的描述下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;__try 使得 __except, __finally 的过滤条件和处理逻辑被 push 到当前线程的异常处理链上&lt;/li&gt;
&lt;li&gt;触发异常时，以异常信息为参数，沿着异常处理链逐个调用 filter 决定处理流程。filter 可以说“忽略该异常”，那么，线程在调用 vectored continue handler 过后继续从异常触发的指令往下执行；如果 filter 说“继续搜索”，那么，我们沿异常处理链访问下个 filter，如果最终都没有匹配的 filter，会调用通过 SetUnhandledExceptionFilter 注册的顶层 handler；如果 filter 说 “匹配”，则准备执行该 filter 对应的 handler (即 __except 的 block)，于是，先调用 vectored exception handler，再进行 Stack unwinding，弹出中间栈帧的时候执行相应的 __finally 块儿，最后，执行匹配位置的 handler。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;第一个例子，filter 说“忽略”，所以，vectored continue handler 被调用，整个程序会输出 123 。注意返回 EXCEPTION_CONTINUE_EXECUTION 的 filter 需要调整 Eip。&lt;/p&gt;
 &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;windows.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; LONG NTAPI &lt;span class=&quot;title&quot;&gt;MyFramedFilter&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(_EXCEPTION_POINTERS *ExceptionInfo)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// skip the illegal op:  *reinterpret_cast&amp;lt;int*&amp;gt;(nullptr) = 0;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;PCONTEXT&amp;gt;(ExceptionInfo-&amp;gt;ContextRecord)-&amp;gt;Eip += &lt;span class=&quot;number&quot;&gt;9&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return EXCEPTION_CONTINUE_EXECUTION;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; LONG NTAPI &lt;span class=&quot;title&quot;&gt;MyVectoredContinueHandler&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(_EXCEPTION_POINTERS *ExceptionInfo)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;2&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return EXCEPTION_CONTINUE_EXECUTION;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Func2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    *&lt;span class=&quot;keyword&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;*&amp;gt;(&lt;span class=&quot;literal&quot;&gt;nullptr&lt;/span&gt;) = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Func1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __try &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Func2();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __except (MyFramedFilter(GetExceptionInformation())) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;never&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;3&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    AddVectoredContinueHandler(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, MyVectoredContinueHandler);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Func1();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第二个例子，filter 说“匹配”，所以先执行 filter，在栈开解的时候执行 __finally block ，最后是 __except 的 handler 和之后的代码。程序输出 1234 。&lt;/p&gt;
 &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; LONG NTAPI &lt;span class=&quot;title&quot;&gt;MyFramedFilter&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(_EXCEPTION_POINTERS *ExceptionInfo)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return EXCEPTION_EXECUTE_HANDLER;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Func2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __try &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        *&lt;span class=&quot;keyword&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;*&amp;gt;(&lt;span class=&quot;literal&quot;&gt;nullptr&lt;/span&gt;) = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __finally &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;2&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Func1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __try &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Func2();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __except (MyFramedFilter(GetExceptionInformation())) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;3&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;4&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Func1();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;第三个例子，filter 说“继续搜索”，于是顶层的 filter 被调用，这里顶层 filter 返回匹配，所以栈开解，调用内层的 __finally handler。程序输出 123 。&lt;/p&gt;
 &lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; LONG NTAPI &lt;span class=&quot;title&quot;&gt;MyFramedFilter&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(_EXCEPTION_POINTERS *ExceptionInfo)&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;1&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return EXCEPTION_CONTINUE_SEARCH;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; LONG NTAPI &lt;span class=&quot;title&quot;&gt;MyTopLevelFilter&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(_EXCEPTION_POINTERS *ExceptionInfo)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;2&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    return EXCEPTION_EXECUTE_HANDLER;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Func2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __try &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        *&lt;span class=&quot;keyword&quot;&gt;reinterpret_cast&lt;/span&gt;&amp;lt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt;*&amp;gt;(&lt;span class=&quot;literal&quot;&gt;nullptr&lt;/span&gt;) = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __finally &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;3&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Func1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __try &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Func2();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    __except (MyFramedFilter(GetExceptionInformation())) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;never&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;puts&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;never&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    SetUnhandledExceptionFilter(MyTopLevelFilter);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Func1();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;对比高级语言的异常&quot;&gt;&lt;a href=&quot;#对比高级语言的异常&quot; class=&quot;headerlink&quot; title=&quot;对比高级语言的异常&quot;&gt;&lt;/a&gt;对比高级语言的异常&lt;/h3&gt;&lt;p&gt;相比高级语言中的 try/catch/finally ， Windows 的 SEH 多了这些优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;能够捕获非法内存访问等硬件异常 (EXCEPTION_INT_DIVIDE_BY_ZERO, EXCEPTION_INT_OVERFLOW, EXCEPTION_ACCESS_VIOLATION)。&lt;/li&gt;
&lt;li&gt;可以从异常触发点继续执行 (EXCEPTION_CONTINUE_EXECUTION)。&lt;/li&gt;
&lt;li&gt;可以在判断 __try block 有没有被完全执行 (AbnormalTermination)。&lt;/li&gt;
&lt;li&gt;filter expression 比高级语言中的异常类型匹配更强大。&lt;/li&gt;
&lt;li&gt;捕获的异常信息可以用于创建 MiniDump 等 (_EXCEPTION_POINTERS)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下是缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++ 的异常处理可能不是通过 SEH 实现，于是结构化异常抛出时，类析构函数不会被调用。&lt;/li&gt;
&lt;li&gt;特定于 Windows 平台。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&quot;结语&quot;&gt;&lt;a href=&quot;#结语&quot; class=&quot;headerlink&quot; title=&quot;结语&quot;&gt;&lt;/a&gt;结语&lt;/h3&gt;&lt;p&gt;这是一篇即使放到10年前都不算新的文章，写它，更算是把我学习的结果记下来，以及刻意的丰富下博客内容吧。&lt;/p&gt;
&lt;p&gt;就这篇文章讨论的这个话题而言，还是再推荐下 &lt;a href=&quot;https://book.douban.com/subject/3235659/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Windows核心编程&lt;/a&gt; 。尽管这次我没看这本书，但 Jeffrey 的书总是深入浅出、鞭辟入里。我认为进入一个新领域时，如果正好有他的书，那一定是从入门到进阶的好机会。比如，学习 .Net 就推荐他的 &lt;a href=&quot;https://book.douban.com/subject/4112979/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CLR via C#&lt;/a&gt;。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;上一次在 Windows 上用 C/C++ 做正经项目、需要做严格异常处理和调试的场合，已经是 5 年前了，那时我还在维护 PC 端游戏引擎。&lt;br&gt;
    
    </summary>
    
      <category term="Error Handling" scheme="http://blog.wbscan.com/categories/Error-Handling/"/>
    
    
      <category term="Windows" scheme="http://blog.wbscan.com/tags/Windows/"/>
    
      <category term="Exception" scheme="http://blog.wbscan.com/tags/Exception/"/>
    
      <category term="MiniDump" scheme="http://blog.wbscan.com/tags/MiniDump/"/>
    
      <category term="SEH" scheme="http://blog.wbscan.com/tags/SEH/"/>
    
  </entry>
  
  <entry>
    <title>怎么用GithubPages+Hexo+NexT搭建博客</title>
    <link href="http://blog.wbscan.com/2016/05/08/HowToSetupTheHexoBasedBlog/"/>
    <id>http://blog.wbscan.com/2016/05/08/HowToSetupTheHexoBasedBlog/</id>
    <published>2016-05-07T20:15:18.000Z</published>
    <updated>2016-05-08T13:18:49.022Z</updated>
    
    <content type="html">&lt;p&gt;我想自己搭博客很久了，之前是不会 Web，等到终于会做网站的时候，已经嫌麻烦不太想弄了，所以转而寻求现成的博客生成、托管方案。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;博客托管和文章备份一定要靠谱，一番考察过后，还是 &lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub Pages&lt;/a&gt; 最省事；而基于 GitHub Pages 的静态网站方案中，对比&lt;a href=&quot;https://jekyllrb.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Jekyll&lt;/a&gt; 和 &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt; ，后者诞生得晚、活跃的主题/插件多，安装和部署都更简单。在 Hexo 主题中，&lt;a href=&quot;http://theme-next.iissnan.com/tag-plugins.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NexT&lt;/a&gt; (&lt;a href=&quot;http://notes.iissnan.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Demo&lt;/a&gt;)又比绝大部分竞争对手更成熟，于是最终方案就是 GitHub Pages + Hexo + NexT. &lt;/p&gt;
&lt;p&gt;在考察各种教程和主题后，这是我的实施过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先看&lt;a href=&quot;https://pages.github.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub Pages&lt;/a&gt;文档，用它托管一个只包含 index.html 的静态网站。成功后，你能通过&lt;code&gt;http://username.github.io&lt;/code&gt;访问这个静态博客。&lt;/li&gt;
&lt;li&gt;注册域名，添加 &lt;a href=&quot;https://en.wikipedia.org/wiki/CNAME_record&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CNAME record&lt;/a&gt; 重定向到你刚创建的 GitHub Pages 上的静态博客。另外，GitHub Pages 那边也需要配置一下： &lt;a href=&quot;https://help.github.com/articles/using-a-custom-domain-with-github-pages/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Using a custom domain with GitHub Pages&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;了解 &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt; 这个静态博客生成器，按照 Doc 在本机创建一个博客模板。此时运行&lt;code&gt;hexo generate&lt;/code&gt;命令可以根据初始模板生成对应的静态网站，再 push 到前面创建的 GitHub Pages 的 Repo 的话，其实一个基本的博客已经完工。这里有篇很详细的教程：&lt;a href=&quot;https://xuanwo.org/2015/03/26/hexo-intor/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;史上最详细的Hexo博客搭建图文教程&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;上面的博客还太简单，所以我们要用 Hexo 主题。Github 上 Star 最多的是&lt;a href=&quot;http://theme-next.iissnan.com/getting-started.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;NextT&lt;/a&gt;，质量很高，也挺好看 (&lt;a href=&quot;http://notes.iissnan.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Demo&lt;/a&gt;)，改几行配置文件就能完成很多事情：&lt;ul&gt;
&lt;li&gt;多说/Disqus 评论&lt;/li&gt;
&lt;li&gt;百度/腾讯/Google 统计&lt;/li&gt;
&lt;li&gt;微信打赏/公众号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;这就是全部了，以后想添加新文章，在 Hexo 的模板 Repo 里&lt;code&gt;hexo new &amp;quot;post_name&amp;quot;&lt;/code&gt;，再运行&lt;code&gt;hexo generate&lt;/code&gt;，最后 push 到&lt;code&gt;https://github.com/username/username.github.io&lt;/code&gt; ，一篇新的博文就发布了。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;我想自己搭博客很久了，之前是不会 Web，等到终于会做网站的时候，已经嫌麻烦不太想弄了，所以转而寻求现成的博客生成、托管方案。&lt;br&gt;
    
    </summary>
    
      <category term="Web" scheme="http://blog.wbscan.com/categories/Web/"/>
    
    
      <category term="Web" scheme="http://blog.wbscan.com/tags/Web/"/>
    
      <category term="GitHub" scheme="http://blog.wbscan.com/tags/GitHub/"/>
    
  </entry>
  
</feed>
